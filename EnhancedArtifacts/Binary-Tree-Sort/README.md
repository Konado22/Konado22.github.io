# Algorithms and Data Structures: Cpp-Data-Sort <br/>

## Description
A completed enhancement of coursework from CS-300 Cpp Data Structures. For our final assessment in this course, we were to choose a data structure to implement for storing objects read from a csv file. The goal was to implement the fastest data structure between a variety of structures built into C++. I had originally chosen to implement a vector but for enhancements have built a tree. Trees allow for potentially shorter time requirements to complete iterations and can prove to be a more valuable data structure for the requirements of incorporating the fastest data structure for the assignment. <br/>

## Goals
This project's aim was an enhancement of previous work completed in CS-300. In this course we learned about various data structures in C++ and characteristics of these structures. The final project for this course was to create a data structure to store data read from an external CSV file. By creating this data structure and implementing the methodology to iterate through it, we also were tasked with justifying our decision to include the specific data structure we chose. Upon reflection and enhancements of this artifact I have transitioned to a binary tree structure rather than a standard vector. Below I have provided a list of enhancements performed to the artifact in line with course objectives that best showcase my work within data structures and algorithms within the SNHU computer science program. <br/>
<ul>
  <li>Transition from vector to Binary Tree</li>
  <li>Implmement functionality to iterate through tree</li>
  <li>Utilize parser file to create objects from input file</li>
  <li>Build functionality to measure time performance of the programs execution</li>
</ul>

## Reflection

I had originally chosen to implement a vector for the final project submission for this course. Iteration of a vector was easy to implement and was very linear in terms of methodology to iterate over and through the values within the stored vector. To demonstrate an understanding of data structures and algorithms I wanted to implement a binary tree data structure. Though methodology constructed we can get faster computing times through the tree than we can with vectors. O notation is used to describe the computational speed of algorithms and how it is affected as data structures grow with information. Utilization of a vector proved to implement a 0(n) logic. This explains that for every entry n in the vector that it would have linear correlation to the time it takes to complete an iteration. This creates consistency, but with larger amount of data this information can take many iterations to get information from. With implementation of a binary tree, however, there is room to eliminate unnecessary time iterating through this list. The o notation of a binary tree is best cases can exceed the vector with a 0log(n) time due to not having to iterate through every entry. At worst case the tree resembles the same speeds as a vector. 
 <br/><br/> 
 By optimizing this data structure, I can demonstrate designing and evaluating computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices. The goal of implementing a data structure that can prove to be the fastest was essential to choosing a proper data structure for this course objective. By constructing logic for iteration of the tree I demonstrate the ability to solve logic problems and implement them into the software. By choosing to utilize a tree and providing valid explanation I am clearly able to articulate approaches to solving complex logic problems in the software. By commenting and providing explanation of logic I can demonstrate best practices in evaluating computing solutions<br/><br/>

