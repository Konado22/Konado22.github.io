# Algorithms and Data Structures: Cpp-Data-Sort <br/>

## Description
A completed ehancement of coursework from CS-300 Cpp Data Structures. For our final assessment in this course we were to chose a data structure to implement for storing objects read from a csv file. The goal was to implement the fastest data structure between a variety of structures built into C++. I had originally chosen to implement a vector but for enhancements have built a tree.<br/>

## Goals
This projects aim was an enhancement of previous work completed in CS-300. In this course we learned about various data structure in C++ and characteristics of these structures. The final project for this course was to create a data structure to store data read from an external CSV file. By creating this data structure and implementing the methodology to iterate through it, we also were tasked with justifying our descision to include the specific data structure we chose. Upon reflection and enhancements of this artifact I have transitioned to a binary tree structure rather than a standard vector. Below I have provided a list of enhancements performed to the artifact in line with course objectives that best showcases my work within data structures and algorithms within the SNHU computer science program.
<ul>
  <li>Transition from vector to Binary Tree</li>
  <li>Implmement functionality to iterate through tree</li>
  <li>Utilize parser file to create objects from input file</li>
  <li>Build functionality to measure time performance of the programs execution</li>
</ul>

## Reflection

I had orginally chosen to implement a vector for the final project submission for this course. Iteration of a vector was easy to implement and was very linear in terms of methodology to iterate over and through the values within the stored vector. To demonstrate an understanding of data structures and algorithms I wanted to implmeent a binary tree data structure. Though methodology constructed we can get faster computing times through the tree than we can with vectors. O notation is used to describe the computational speed of algorithms and how it is affected as data structures grow with information. Utilization of a vector proved to implement a 0(n) logic. This explains that for every entry n in the vector that it would have linear correlation to the time it takes to complete an iteration. This creates consistency, but with larger amount of data this information can take many iterations to get information from. With implmemtation of a binary tree however there is room to elmiminate uneccessary time iterating through this list. The o notation of a binary tree is best cases can exceed the vector with a 0log(n) time due to not having to iterate through every entry. At worst case the tree resembles the same speeds as a vector.<br/><br/> By optimizing this data structure I am able to demonstrate designing and evaluating computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices. The goal of implementing a data structure that can prove to be the fastest was essential to chosing a proper data structure for this course objective. By constructing logic for iteration of the tree I demonstrate the ability to solve logic problems and imlement them into the software. By chosing to usilize a tree and providing valid explanation I am clearly able to articulate approaches to solving comples logic problems in the software. By commenting and providing explanation of logic I can demonstrate best practices in evaluating computing solutions<br/><br/>

